diff --git a/agents/application/cron.py b/agents/application/cron.py
index 6620e95..179ca41 100644
--- a/agents/application/cron.py
+++ b/agents/application/cron.py
@@ -1,15 +1,16 @@
-from agents.application.trade import Trader
-
 import time
 
-from scheduler import Scheduler
+from scheduler import Scheduler as BaseScheduler
 from scheduler.trigger import Monday
 
+from agents.application.trade import Trader
+
 
-class Scheduler:
+class TradingScheduler:
     def __init__(self) -> None:
         self.trader = Trader()
-        self.schedule = Scheduler()
+        self.schedule = BaseScheduler()
+        self.schedule.weekly(Monday(), self.trader.one_best_trade)
 
     def start(self) -> None:
         while True:
@@ -17,8 +18,5 @@ class Scheduler:
             time.sleep(1)
 
 
-class TradingAgent(Scheduler):
-    def __init__(self) -> None:
-        super()
-        self.trader = Trader()
-        self.weekly(Monday(), self.trader.one_best_trade)
+if __name__ == "__main__":
+    TradingScheduler().start()
diff --git a/agents/application/executor.py b/agents/application/executor.py
index ff0d996..13adad0 100644
--- a/agents/application/executor.py
+++ b/agents/application/executor.py
@@ -35,6 +35,11 @@ class Executor:
         self.token_limit = max_token_model.get(default_model)
         self.prompter = Prompter()
         self.openai_api_key = os.getenv("OPENAI_API_KEY")
+
+        # Risk controls (hard caps)
+        self.max_portfolio_fraction_per_trade = float(os.getenv("MAX_PORTFOLIO_FRACTION_PER_TRADE", "0.02"))
+        self.min_portfolio_fraction_per_trade = float(os.getenv("MIN_PORTFOLIO_FRACTION_PER_TRADE", "0.001"))
+
         self.llm = ChatOpenAI(
             model=default_model, #gpt-3.5-turbo"
             temperature=0,
@@ -182,11 +187,30 @@ class Executor:
         return content
 
     def format_trade_prompt_for_execution(self, best_trade: str) -> float:
-        data = best_trade.split(",")
-        # price = re.findall("\d+\.\d+", data[0])[0]
-        size = re.findall("\d+\.\d+", data[1])[0]
+        """
+        Parse LLM trade output safely and apply hard risk caps.
+        Expected size is a portfolio fraction (e.g. 0.01 = 1%).
+        """
+        matches = re.findall(r"\d*\.?\d+", best_trade or "")
+        if not matches:
+            raise ValueError(f"Could not parse trade size from LLM output: {best_trade}")
+
+        # Heuristic: use first value in [0,1] as fraction, else fallback to first parsed number
+        candidate_sizes = [float(x) for x in matches]
+        size_fraction = None
+        for c in candidate_sizes:
+            if 0 < c <= 1:
+                size_fraction = c
+                break
+        if size_fraction is None:
+            size_fraction = candidate_sizes[0]
+
+        # Clamp to configured risk limits
+        size_fraction = max(self.min_portfolio_fraction_per_trade, size_fraction)
+        size_fraction = min(self.max_portfolio_fraction_per_trade, size_fraction)
+
         usdc_balance = self.polymarket.get_usdc_balance()
-        return float(size) * usdc_balance
+        return float(size_fraction) * usdc_balance
 
     def source_best_market_to_create(self, filtered_markets) -> str:
         prompt = self.prompter.create_new_market(filtered_markets)
diff --git a/agents/application/trade.py b/agents/application/trade.py
index b779d91..f22453c 100644
--- a/agents/application/trade.py
+++ b/agents/application/trade.py
@@ -3,6 +3,7 @@ from agents.polymarket.gamma import GammaMarketClient as Gamma
 from agents.polymarket.polymarket import Polymarket
 
 import shutil
+import time
 
 
 class Trader:
@@ -15,54 +16,64 @@ class Trader:
         self.clear_local_dbs()
 
     def clear_local_dbs(self) -> None:
-        try:
-            shutil.rmtree("local_db_events")
-        except:
-            pass
-        try:
-            shutil.rmtree("local_db_markets")
-        except:
-            pass
-
-    def one_best_trade(self) -> None:
+        for path in ["local_db_events", "local_db_markets"]:
+            try:
+                shutil.rmtree(path)
+            except FileNotFoundError:
+                pass
+            except Exception as err:
+                print(f"[warn] could not delete {path}: {err}")
+
+    def one_best_trade(self, max_retries: int = 3, retry_sleep_seconds: int = 3) -> None:
         """
+        one_best_trade evaluates events, markets, and orderbooks,
+        then computes a trade candidate.
 
-        one_best_trade is a strategy that evaluates all events, markets, and orderbooks
+        Safety: bounded retries to avoid infinite recursion/runaway loops.
+        """
+        last_error = None
 
-        leverages all available information sources accessible to the autonomous agent
+        for attempt in range(1, max_retries + 1):
+            try:
+                self.pre_trade_logic()
 
-        then executes that trade without any human intervention
+                events = self.polymarket.get_all_tradeable_events()
+                print(f"1. FOUND {len(events)} EVENTS")
 
-        """
-        try:
-            self.pre_trade_logic()
+                filtered_events = self.agent.filter_events_with_rag(events)
+                print(f"2. FILTERED {len(filtered_events)} EVENTS")
+
+                markets = self.agent.map_filtered_events_to_markets(filtered_events)
+                print()
+                print(f"3. FOUND {len(markets)} MARKETS")
 
-            events = self.polymarket.get_all_tradeable_events()
-            print(f"1. FOUND {len(events)} EVENTS")
+                print()
+                filtered_markets = self.agent.filter_markets(markets)
+                print(f"4. FILTERED {len(filtered_markets)} MARKETS")
 
-            filtered_events = self.agent.filter_events_with_rag(events)
-            print(f"2. FILTERED {len(filtered_events)} EVENTS")
+                if not filtered_markets:
+                    print("[info] No markets passed filters. Skipping trade.")
+                    return
 
-            markets = self.agent.map_filtered_events_to_markets(filtered_events)
-            print()
-            print(f"3. FOUND {len(markets)} MARKETS")
+                market = filtered_markets[0]
+                best_trade = self.agent.source_best_trade(market)
+                print(f"5. CALCULATED TRADE {best_trade}")
 
-            print()
-            filtered_markets = self.agent.filter_markets(markets)
-            print(f"4. FILTERED {len(filtered_markets)} MARKETS")
+                amount = self.agent.format_trade_prompt_for_execution(best_trade)
+                print(f"6. SAFE-SIZED AMOUNT {amount}")
 
-            market = filtered_markets[0]
-            best_trade = self.agent.source_best_trade(market)
-            print(f"5. CALCULATED TRADE {best_trade}")
+                # Please refer to TOS before uncommenting: polymarket.com/tos
+                # trade = self.polymarket.execute_market_order(market, amount)
+                # print(f"7. TRADED {trade}")
+                return
 
-            amount = self.agent.format_trade_prompt_for_execution(best_trade)
-            # Please refer to TOS before uncommenting: polymarket.com/tos
-            # trade = self.polymarket.execute_market_order(market, amount)
-            # print(f"6. TRADED {trade}")
+            except Exception as e:
+                last_error = e
+                print(f"[error] attempt {attempt}/{max_retries} failed: {e}")
+                if attempt < max_retries:
+                    time.sleep(retry_sleep_seconds)
 
-        except Exception as e:
-            print(f"Error {e} \n \n Retrying")
-            self.one_best_trade()
+        raise RuntimeError(f"one_best_trade failed after {max_retries} retries: {last_error}")
 
     def maintain_positions(self):
         pass
diff --git a/agents/connectors/search.py b/agents/connectors/search.py
index 0e1a2fe..ce18997 100644
--- a/agents/connectors/search.py
+++ b/agents/connectors/search.py
@@ -5,12 +5,16 @@ from tavily import TavilyClient
 
 load_dotenv()
 
-openai_api_key = os.getenv("OPEN_API_KEY")
+# NOTE: Keep this key name aligned with .env.example
+openai_api_key = os.getenv("OPENAI_API_KEY")
 tavily_api_key = os.getenv("TAVILY_API_KEY")
 
-# Step 1. Instantiating your TavilyClient
-tavily_client = TavilyClient(api_key=tavily_api_key)
+# Instantiate Tavily client only if key is present
+# (prevents hard crashes in environments where search is optional)
+tavily_client = TavilyClient(api_key=tavily_api_key) if tavily_api_key else None
 
-# Step 2. Executing a context search query
-context = tavily_client.get_search_context(query="Will Biden drop out of the race?")
-# Step 3. That's it! You now have a context string that you can feed directly into your RAG Application
+
+def get_search_context(query: str) -> str:
+    if not tavily_client:
+        raise RuntimeError("TAVILY_API_KEY is not configured")
+    return tavily_client.get_search_context(query=query)
diff --git a/agents/polymarket/polymarket.py b/agents/polymarket/polymarket.py
index 3fe1237..f037c2d 100644
--- a/agents/polymarket/polymarket.py
+++ b/agents/polymarket/polymarket.py
@@ -361,7 +361,6 @@ class Polymarket:
 def test():
     host = "https://clob.polymarket.com"
     key = os.getenv("POLYGON_WALLET_PRIVATE_KEY")
-    print(key)
     chain_id = POLYGON
 
     # Create CLOB client and get/set API credentials
